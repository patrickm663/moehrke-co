"use strict";

exports.__esModule = true;
exports.usePollForNodeManifest = exports.poll = exports.errorMessages = void 0;

var _react = require("react");

var _utils = require("./utils");

var _constants = require("./constants");

const errorMessages = {
  default: `We've run into an error previewing your site.`,
  noPageFound: `Your Gatsby site didn't create a page for the content you're trying to view.`
};
exports.errorMessages = errorMessages;
const betweenPollWaitTimeMs = 1000;
const minutesUntilNodeManifestTimeout = 0.5;
/**
 * The polling fn for the ContentLoader component to poll for node manifest files for the users Gatsby site
 */

const poll = async pollArgs => {
  const {
    shouldPoll: shouldPollInput,
    showError,
    manifestId,
    sourcePluginName,
    pollCount,
    contentLoaderInfo,
    siteId,
    pollCallback,
    frontendUrl,
    waitThenTriggerNextPoll,
    setErrorMessage,
    setShowError,
    setRedirectUrl,
    setLoadingDuration
  } = pollArgs; // if any of these are true we won't continue polling in this invocation of poll()

  if (!shouldPollInput || showError) {
    return;
  }

  if (manifestId && sourcePluginName && frontendUrl) {
    if (_constants.DEBUG_CONTENT_SYNC_MODE) {
      console.info(`#${pollCount} poll for manifest at ${contentLoaderInfo === null || contentLoaderInfo === void 0 ? void 0 : contentLoaderInfo.previewUrl}/__node-manifests/${sourcePluginName}/${manifestId}.json`);
    }

    try {
      var _error$message;

      const {
        shouldPoll,
        error,
        manifest,
        redirectUrl,
        loadingDuration
      } = await (0, _utils.fetchNodeManifest)({
        manifestId,
        siteId,
        sourcePluginName,
        pollCallback,
        frontendUrl,
        setShowError
      });

      if (shouldPoll) {
        waitThenTriggerNextPoll();
        return;
      }

      if ((manifest === null || manifest === void 0 ? void 0 : manifest.foundPageBy) === `none`) {
        if (_constants.DEBUG_CONTENT_SYNC_MODE) {
          console.info(`Gatsby site didn't create a page for the node that's being loaded.`);
        }

        setErrorMessage(errorMessages.noPageFound);
        setShowError(true);
        return;
      }

      const is404 = (error === null || error === void 0 ? void 0 : (_error$message = error.message) === null || _error$message === void 0 ? void 0 : _error$message.includes(`invalid json response body`)) || typeof error !== `undefined` && `code` in error && (error === null || error === void 0 ? void 0 : error.code) === 404; // 404's may just mean that the build hasn't finished.

      if (is404) {
        if (typeof pollCallback === `function`) {
          pollCallback();
        }

        waitThenTriggerNextPoll();

        if (_constants.DEBUG_CONTENT_SYNC_MODE) {
          console.info(`Manifest request 404'd (might not be available yet, rechecking).`);
        }
      } else if (error) {
        console.error(`Manifest request errored.`, error);

        if (`passwordProtected` in error && error.passwordProtected) {
          setErrorMessage(`Content Sync does not currently work with password protected Previews.`);
        }

        setShowError(true);
      }

      if (redirectUrl) {
        setRedirectUrl(redirectUrl);
      }

      if (loadingDuration) {
        setLoadingDuration(loadingDuration);
      }
    } catch (error) {
      console.error(`Manifest Gatsby function request errored.`, error);
      setShowError(true);
    }
  }
};
/**
 * Returns a function which when called handles node manifest polling timeouts if builds go idle for too long
 */


exports.poll = poll;

const useHandlePollingTimeout = ({
  contentLoaderInfo,
  setShowError
}) => {
  const [idleSince, setIdleSince] = (0, _react.useState)(null);
  const [lastPollBuildStatus, setLastPollBuildStatus] = (0, _react.useState)(null);

  const statusHas = state => {
    var _contentLoaderInfo$pr;

    return !!(contentLoaderInfo !== null && contentLoaderInfo !== void 0 && (_contentLoaderInfo$pr = contentLoaderInfo.previewBuildStatus) !== null && _contentLoaderInfo$pr !== void 0 && _contentLoaderInfo$pr.includes(state));
  };
  /**
   * handlePollingTimeout Handles updating timeout state and returns
   * true/false for whether or not the ui should timeout.
   */


  const handlePollingTimeout = () => {
    // first check if we should timeout
    if (typeof idleSince === `number`) {
      const minutesSinceIdle = (Date.now() - idleSince) / 1000 / 60;
      const shouldTimeout = minutesSinceIdle >= minutesUntilNodeManifestTimeout;

      if (shouldTimeout) {
        console.warn(`Timed out waiting for node manifest. Builds are idle and no manifest was found after ${minutesSinceIdle} minutes.`); // make sure that the process times out before showing any errors

        setShowError(true);
        return true;
      }
    }

    const buildsAreCurrentlyIdle = statusHas(`ERROR`) || statusHas(`SUCCESS`); // check if we're idle and store the current timestamp if we are

    if ( // if a build status exists
    contentLoaderInfo !== null && contentLoaderInfo !== void 0 && contentLoaderInfo.previewBuildStatus && // and it's different than the last build status we stored
    lastPollBuildStatus !== contentLoaderInfo.previewBuildStatus && // and builds are idle
    buildsAreCurrentlyIdle) {
      // store the time we started idling.
      const idleTimestamp = Date.now();

      if (_constants.DEBUG_CONTENT_SYNC_MODE) {
        console.info(`Setting idle time to now ${idleTimestamp} and last build status to ${contentLoaderInfo.previewBuildStatus}`);
      }

      setLastPollBuildStatus(contentLoaderInfo.previewBuildStatus);
      setIdleSince(idleTimestamp);
    } // otherwise if we're not idle nullify the idleSince state so we don't timeout if we previously stored an idle start time timestamp
    else if (!buildsAreCurrentlyIdle) {
      if (_constants.DEBUG_CONTENT_SYNC_MODE) {
        console.info({
          buildStatus: contentLoaderInfo === null || contentLoaderInfo === void 0 ? void 0 : contentLoaderInfo.previewBuildStatus
        });
      }

      setIdleSince(null);
    }

    return false;
  };

  return {
    handlePollingTimeout
  };
};
/**
 * This hook polls for node manifest files and handles polling timeouts when the build queue has gone idle for too long with no manifest file being found.
 */


const usePollForNodeManifest = ({
  contentLoaderInfo,
  shouldPoll,
  manifestId,
  sourcePluginName,
  siteId,
  pollCallback
}) => {
  const [showError, setShowError] = (0, _react.useState)(false);
  const [errorMessage, setErrorMessage] = (0, _react.useState)(errorMessages.default);
  const [pollCount, setPollCount] = (0, _react.useState)(0);
  const {
    handlePollingTimeout
  } = useHandlePollingTimeout({
    contentLoaderInfo,
    setShowError
  });
  const [redirectUrl, setRedirectUrl] = (0, _react.useState)(undefined);
  const [loadingDuration, setLoadingDuration] = (0, _react.useState)(0);

  const triggerNextPoll = () => setPollCount(pollCount + 1);

  const waitThenTriggerNextPoll = () => {
    setTimeout(triggerNextPoll, betweenPollWaitTimeMs);
  }; // only polling above 0 allows us to manually start polling.
  // The first useEffect run of poll will have pollCount set to 0.
  // Calling triggerNextPoll will increment it to 1 and then pollingHasStarted will be true.


  const pollingHasStarted = pollCount > 0;
  const frontendUrl = (contentLoaderInfo === null || contentLoaderInfo === void 0 ? void 0 : contentLoaderInfo.previewUrl) || false;
  (0, _react.useEffect)(function handlePoll() {
    if (_constants.DEBUG_CONTENT_SYNC_MODE) {
      console.info({
        pollingHasStarted,
        shouldPoll
      });
    }

    if (!pollingHasStarted || !shouldPoll) {
      return;
    }

    const shouldTimeout = handlePollingTimeout();

    if (!showError && !shouldTimeout) {
      poll({
        pollCount,
        shouldPoll,
        showError,
        manifestId,
        sourcePluginName,
        contentLoaderInfo,
        siteId,
        pollCallback,
        frontendUrl,
        waitThenTriggerNextPoll,
        setErrorMessage,
        setShowError,
        setRedirectUrl,
        setLoadingDuration
      });
    } else if (_constants.DEBUG_CONTENT_SYNC_MODE) {
      console.log({
        showError,
        shouldTimeout
      });
    }
  }, // whenever pollCount changes or if we enable shouldPoll we re-run poll()
  [pollCount, shouldPoll]);
  (0, _react.useEffect)(function startPolling() {
    /**
     * When we first receive data from apollo we start polling
     */
    if (!pollingHasStarted && contentLoaderInfo) {
      if (_constants.DEBUG_CONTENT_SYNC_MODE) {
        console.info(`Starting to poll for preview build updates`);
      }

      triggerNextPoll();
    }
  }, [contentLoaderInfo]);
  return {
    redirectUrl,
    loadingDuration,
    errorMessage: showError ? errorMessage : null
  };
};

exports.usePollForNodeManifest = usePollForNodeManifest;