"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = exports.PreviewIndicator = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _react = _interopRequireWildcard(require("react"));

var _indicatorProvider = _interopRequireDefault(require("../context/indicatorProvider"));

var _enums = require("../models/enums");

var _utils = require("../utils");

var _buttons = require("./buttons");

var _Style = _interopRequireDefault(require("./Style"));

var _usePollForNodeManifest = require("../utils/use-poll-for-node-manifest");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const POLLING_INTERVAL = process.env.GATSBY_PREVIEW_POLL_INTERVAL ? parseInt(process.env.GATSBY_PREVIEW_POLL_INTERVAL) : 2000;
const PAGE_DATA_RETRY_LIMIT = 60;

const PreviewIndicator = ({
  children
}) => /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_Style.default, null), /*#__PURE__*/_react.default.createElement("div", {
  "data-testid": "preview-status-indicator",
  "data-gatsby-preview-indicator": "root",
  "aria-live": "assertive"
}, children));

exports.PreviewIndicator = PreviewIndicator;

const getContentSyncInfoFromURL = () => {
  const urlSearchParams = new URLSearchParams(window.location.search); // mid and plgn are shortened to keep the url short

  const {
    mid: manifestId,
    plgn: pluginName
  } = JSON.parse(atob(urlSearchParams.get(`csync`) || ``) || `{}`);

  if (!manifestId || !pluginName) {
    return null;
  }

  return {
    manifestId,
    pluginName
  };
};

let buildId = ``;
let pageData;
let latestCheckedBuild;
let refreshNeeded = false;

const Indicator = () => {
  var _buildInfo$siteInfo, _buildInfo$currentBui, _buildInfo$siteInfo2;

  const [buildInfo, setBuildInfo] = (0, _react.useState)();
  const [contentSyncInfo, setContentSyncInfo] = (0, _react.useState)(null);
  const usingContentSync = !!contentSyncInfo;
  const timeoutRef = (0, _react.useRef)(null);
  const shouldPoll = (0, _react.useRef)(false);
  const trackedInitialLoad = (0, _react.useRef)(false);
  const {
    track
  } = (0, _utils.useTrackEvent)();

  async function fetchPageData() {
    const urlHostString = window.location.origin;
    const pathAdjustment = window.location.pathname === `/` ? `/index` : window.location.pathname;
    const normalizedPath = `/page-data${pathAdjustment}/page-data.json`.replace(/\/\//g, `/`);
    const url = urlHostString + normalizedPath;

    try {
      const resp = await fetch(url);
      const data = await resp.text(); // for local dev with `gatsby develop` where page-data.json files never 404 and return an empty object instead.

      if (data === `{}`) {
        // for local development, force an error if page is missing.
        const err = new Error(`Not Found`);
        err.status = 404;
        throw err;
      }

      return {
        data,
        errorMessage: null
      };
    } catch (e) {
      if (e.status === 404) {
        return {
          data: null,
          errorMessage: `This page has moved.`
        };
      } else {
        return {
          data: null,
          errorMessage: null
        };
      }
    }
  }

  (0, _react.useEffect)(() => {
    const fetchData = async () => {
      const {
        data
      } = await fetchPageData();
      pageData = data;
    };

    const contentSyncUrlParamInfo = getContentSyncInfoFromURL(); // prefer content sync

    if (contentSyncUrlParamInfo) {
      setContentSyncInfo(contentSyncUrlParamInfo);
    } // fall back to diffing page data
    else {
      fetchData();
    }
  }, []);
  const pollForNodeManifestArgs = {
    contentLoaderInfo: {
      orgId: buildInfo === null || buildInfo === void 0 ? void 0 : (_buildInfo$siteInfo = buildInfo.siteInfo) === null || _buildInfo$siteInfo === void 0 ? void 0 : _buildInfo$siteInfo.orgId,
      previewBuildStatus: buildInfo === null || buildInfo === void 0 ? void 0 : (_buildInfo$currentBui = buildInfo.currentBuild) === null || _buildInfo$currentBui === void 0 ? void 0 : _buildInfo$currentBui.buildStatus,
      previewUrl: // for local dev / debugging
      process.env.GATSBY_PREVIEW_URL || // for production
      window.location.origin
    },
    manifestId: contentSyncInfo === null || contentSyncInfo === void 0 ? void 0 : contentSyncInfo.manifestId,
    sourcePluginName: contentSyncInfo === null || contentSyncInfo === void 0 ? void 0 : contentSyncInfo.pluginName,
    siteId: buildInfo === null || buildInfo === void 0 ? void 0 : (_buildInfo$siteInfo2 = buildInfo.siteInfo) === null || _buildInfo$siteInfo2 === void 0 ? void 0 : _buildInfo$siteInfo2.siteId,
    shouldPoll: !!contentSyncInfo
  };
  const {
    redirectUrl: nodeManifestRedirectUrl,
    errorMessage: nodeManifestErrorMessage
  } = (0, _usePollForNodeManifest.usePollForNodeManifest)(pollForNodeManifestArgs);

  _react.default.useEffect(() => {
    if (nodeManifestErrorMessage) {
      console.error(nodeManifestErrorMessage);
    } else if (nodeManifestRedirectUrl) {
      // Force a "This page has updated message" until the page is refreshed
      refreshNeeded = true;
    }
  }, [nodeManifestRedirectUrl, nodeManifestErrorMessage]);

  const hasPageDataChanged = async () => {
    if (buildId !== latestCheckedBuild) {
      let pageDataCounter = 0;
      let hasPageChanged = false;

      while (!hasPageChanged && pageDataCounter <= PAGE_DATA_RETRY_LIMIT) {
        const loadedPageData = pageData;
        const {
          data,
          errorMessage
        } = await fetchPageData();

        if (errorMessage) {
          return {
            hasPageChanged: false,
            errorMessage
          };
        }

        pageDataCounter++;
        hasPageChanged = loadedPageData !== data;

        if (!hasPageChanged) {
          await new Promise(resolve => setTimeout(resolve, POLLING_INTERVAL));
        }
      }

      latestCheckedBuild = buildId;
      return {
        hasPageChanged,
        errorMessage: null
      };
    }

    return {
      hasPageChanged: false,
      errorMessage: null
    };
  };

  const {
    siteInfo,
    currentBuild
  } = buildInfo || {
    siteInfo: {},
    currentBuild: {}
  };
  const {
    orgId,
    siteId
  } = siteInfo || {};

  const pollData = async function pollData() {
    var _newBuildInfo$current, _newBuildInfo$latestB;

    const prettyUrlRegex = /^preview-/;
    const host = window.location.hostname; // currentBuild is the most recent build that is not QUEUED.
    // latestBuild is the most recent build that finished running (ONLY status ERROR or SUCCESS)

    const isOnPrettyUrl = prettyUrlRegex.test(host);
    const {
      siteInfo,
      currentBuild,
      latestBuild
    } = await (0, _utils.getBuildInfo)();

    if (!buildId) {
      if (isOnPrettyUrl || host === `localhost`) {
        buildId = latestBuild === null || latestBuild === void 0 ? void 0 : latestBuild.id;
      } else {
        // Match UUID from preview build URL https://build-af44185e-b8e5-11eb-8529-0242ac130003.gtsb.io
        const buildIdMatch = host === null || host === void 0 ? void 0 : host.match(/build-(.*?(?=\.))/);

        if (buildIdMatch) {
          buildId = buildIdMatch[1];
        }
      }
    }

    const newBuildInfo = {
      currentBuild,
      latestBuild,
      siteInfo,
      isOnPrettyUrl
    };

    if ([_enums.BuildStatus.BUILDING, _enums.BuildStatus.ERROR, _enums.BuildStatus.QUEUED, _enums.BuildStatus.UPLOADING].includes(currentBuild === null || currentBuild === void 0 ? void 0 : currentBuild.buildStatus)) {
      setBuildInfo({ ...newBuildInfo,
        buildStatus: currentBuild === null || currentBuild === void 0 ? void 0 : currentBuild.buildStatus
      });
    } else if (buildId && buildId === (newBuildInfo === null || newBuildInfo === void 0 ? void 0 : (_newBuildInfo$current = newBuildInfo.currentBuild) === null || _newBuildInfo$current === void 0 ? void 0 : _newBuildInfo$current.id)) {
      setBuildInfo({ ...newBuildInfo,
        buildStatus: _enums.BuildStatus.UPTODATE
      });
    } else if (buildId && buildId !== (newBuildInfo === null || newBuildInfo === void 0 ? void 0 : (_newBuildInfo$latestB = newBuildInfo.latestBuild) === null || _newBuildInfo$latestB === void 0 ? void 0 : _newBuildInfo$latestB.id) && (currentBuild === null || currentBuild === void 0 ? void 0 : currentBuild.buildStatus) === _enums.BuildStatus.SUCCESS) {
      if (refreshNeeded) {
        setBuildInfo({ ...newBuildInfo,
          buildStatus: _enums.BuildStatus.SUCCESS
        });
      } else if (!usingContentSync) {
        const {
          hasPageChanged,
          errorMessage
        } = await hasPageDataChanged(buildId);

        if (errorMessage) {
          setBuildInfo({ ...newBuildInfo,
            buildStatus: _enums.BuildStatus.ERROR,
            errorMessage
          });
        } else if (hasPageChanged) {
          // Force a "This page has updated message" until a page is refreshed
          refreshNeeded = true; // Build updated, data for this specific page has changed!

          setBuildInfo({ ...newBuildInfo,
            buildStatus: _enums.BuildStatus.SUCCESS
          });
        } else {
          // Build updated, data for this specific page has NOT changed, no need to refresh content.
          setBuildInfo({ ...newBuildInfo,
            buildStatus: _enums.BuildStatus.UPTODATE
          });
        }
      }
    }

    if (shouldPoll.current) {
      timeoutRef.current = setTimeout(pollData, POLLING_INTERVAL);
    }
  };

  (0, _react.useEffect)(() => {
    if (buildInfo !== null && buildInfo !== void 0 && buildInfo.siteInfo && !trackedInitialLoad.current) {
      track({
        eventType: `PREVIEW_INDICATOR_LOADED`,
        buildId,
        orgId,
        siteId
      });
      trackedInitialLoad.current = true;
    }
  }, [buildInfo]);
  (0, _react.useEffect)(() => {
    shouldPoll.current = true;
    pollData();
    return function cleanup() {
      shouldPoll.current = false;

      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = null;
      }
    };
  }, []);
  const buttonProps = {
    orgId,
    siteId,
    buildId,
    buildStatus: buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.buildStatus,
    isOnPrettyUrl: buildInfo === null || buildInfo === void 0 ? void 0 : buildInfo.isOnPrettyUrl,
    sitePrefix: siteInfo === null || siteInfo === void 0 ? void 0 : siteInfo.sitePrefix,
    createdAt: currentBuild === null || currentBuild === void 0 ? void 0 : currentBuild.createdAt,
    erroredBuildId: currentBuild === null || currentBuild === void 0 ? void 0 : currentBuild.id
  };
  return /*#__PURE__*/_react.default.createElement(_indicatorProvider.default, null, /*#__PURE__*/_react.default.createElement(PreviewIndicator, null, /*#__PURE__*/_react.default.createElement(_buttons.GatsbyIndicatorButton, (0, _extends2.default)({}, buttonProps, {
    buttonIndex: 1
  })), /*#__PURE__*/_react.default.createElement(_buttons.InfoIndicatorButton, (0, _extends2.default)({}, buttonProps, {
    nodeManifestRedirectUrl: nodeManifestRedirectUrl,
    usingContentSync: usingContentSync,
    nodeManifestErrorMessage: nodeManifestErrorMessage,
    buttonIndex: 2
  })), /*#__PURE__*/_react.default.createElement(_buttons.LinkIndicatorButton, (0, _extends2.default)({}, buttonProps, {
    buttonIndex: 3
  }))));
};

var _default = Indicator;
exports.default = _default;