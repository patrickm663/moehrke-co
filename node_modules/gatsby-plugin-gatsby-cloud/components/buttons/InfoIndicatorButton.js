"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _react = _interopRequireWildcard(require("react"));

var _dateFns = require("date-fns");

var _IndicatorButton = _interopRequireDefault(require("./IndicatorButton"));

var _icons = require("../icons");

var _tooltips = require("../tooltips");

var _utils = require("../../utils");

var _constants = require("../../constants");

var _enums = require("../../models/enums");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const InfoIndicatorButton = ({
  buttonIndex,
  orgId,
  siteId,
  erroredBuildId,
  isOnPrettyUrl,
  sitePrefix,
  buildId,
  createdAt,
  buildStatus,
  nodeManifestRedirectUrl,
  usingContentSync,
  nodeManifestErrorMessage
}) => {
  const initialButtonProps = {
    buttonIndex,
    testId: `info`,
    hoverable: true
  };
  const [buttonProps, setButtonProps] = (0, _react.useState)(initialButtonProps);
  const {
    setCookie
  } = (0, _utils.useCookie)();
  const {
    shouldShowFeedback
  } = (0, _utils.useFeedback)();
  const {
    track
  } = (0, _utils.useTrackEvent)();

  const trackClick = () => {
    track({
      eventType: `PREVIEW_INDICATOR_CLICK`,
      orgId,
      siteId,
      buildId,
      name: `info click`
    });
  };

  const trackHover = () => {
    track({
      eventType: `PREVIEW_INDICATOR_HOVER`,
      orgId,
      siteId,
      buildId,
      name: `info hover`
    });
  };

  const updateTootipVisibility = visible => {
    setButtonProps(btnProps => {
      return { ...btnProps,
        tooltip: { ...btnProps.tooltip,
          overrideShow: visible,
          show: visible
        }
      };
    });
  };

  const closeInfoTooltip = () => {
    trackClick();
    setButtonProps(btnProps => {
      return { ...btnProps,
        tooltip: { ...btnProps.tooltip,
          show: false,
          overrideShow: false,
          hoverable: false
        }
      };
    });
  };

  const onTooltipToogle = () => {
    trackClick();
    setButtonProps(btnProps => {
      return { ...btnProps,
        tooltip: { ...btnProps.tooltip,
          overrideShow: !btnProps.tooltip.overrideShow
        }
      };
    });
  };

  const closeFeedbackTooltip = () => {
    setButtonProps(btnProps => {
      return { ...btnProps,
        tooltip: { ...btnProps.tooltip,
          overrideShow: false,
          show: false
        },
        highlighted: false
      };
    }); // added settimeout until reveist to refactor code

    setTimeout(() => {
      const now = new Date();
      setCookie(_constants.FEEDBACK_COOKIE_NAME, now.toISOString());
      setCookie(_constants.INTERACTION_COOKIE_NAME, 0);
    }, 500);
  };

  const onInfoClick = () => {
    if (buttonProps !== null && buttonProps !== void 0 && buttonProps.active && buttonProps !== null && buttonProps !== void 0 && buttonProps.onClick) {
      buttonProps.onClick();
    } else if (buttonProps !== null && buttonProps !== void 0 && buttonProps.active) {
      trackClick();
    }
  };

  (0, _react.useEffect)(() => {
    const displaySimpleMessage = (message, show = false) => {
      setButtonProps({ ...initialButtonProps,
        tooltip: {
          testId: initialButtonProps.testId,
          content: message,
          overrideShow: show,
          show,
          hoverable: !show
        },
        active: true,
        hoverable: !show
      });
    };

    const buildStatusActions = {
      [_enums.BuildStatus.UPTODATE]: () => {
        if (shouldShowFeedback) {
          const url = _constants.FEEDBACK_URL;
          setButtonProps({ ...initialButtonProps,
            tooltip: {
              testId: initialButtonProps.testId,
              content: /*#__PURE__*/_react.default.createElement(_tooltips.FeedbackTooltipContent, {
                url: url,
                onOpened: () => {
                  closeFeedbackTooltip();
                }
              }),
              overrideShow: true,
              closable: true,
              hoverable: false,
              onClose: closeFeedbackTooltip
            },
            active: true,
            highlighted: true,
            hoverable: true
          });
        } else {
          const message = `Preview updated ${(0, _dateFns.formatDistance)(Date.now(), new Date(createdAt), {
            includeSeconds: true
          })} ago`;
          displaySimpleMessage(message);
        }
      },
      [_enums.BuildStatus.SUCCESS]: () => {
        setButtonProps({ ...initialButtonProps,
          tooltip: {
            testId: initialButtonProps.testId,
            content: /*#__PURE__*/_react.default.createElement(_tooltips.BuildSuccessTooltipContent, {
              isOnPrettyUrl: isOnPrettyUrl,
              sitePrefix: sitePrefix,
              buildId: buildId,
              siteId: siteId,
              orgId: orgId
            }),
            overrideShow: true,
            closable: true,
            hoverable: false,
            onClose: closeInfoTooltip
          },
          active: true,
          hoverable: true,
          onClick: onTooltipToogle
        });
      },
      [_enums.BuildStatus.ERROR]: () => {
        setButtonProps({ ...initialButtonProps,
          tooltip: {
            testId: initialButtonProps.testId,
            content: /*#__PURE__*/_react.default.createElement(_tooltips.BuildErrorTooltipContent, {
              siteId: siteId,
              orgId: orgId,
              buildId: erroredBuildId
            }),
            overrideShow: true,
            closable: true,
            hoverable: false,
            onClose: closeInfoTooltip
          },
          active: true,
          hoverable: true,
          onClick: onTooltipToogle
        });
      },
      [_enums.BuildStatus.BUILDING]: () => displaySimpleMessage(`Building your preview...`, true),
      [_enums.BuildStatus.QUEUED]: () => displaySimpleMessage(`Kicking off your build...`, true),
      [_enums.BuildStatus.UPLOADING]: () => displaySimpleMessage(`Deploying...`, true)
    };
    const contentSyncSuccessAction = nodeManifestRedirectUrl ? () => {
      setButtonProps(btnProps => {
        return { ...btnProps,
          tooltip: {
            testId: btnProps.testId,
            content: /*#__PURE__*/_react.default.createElement(_tooltips.BuildSuccessTooltipContent, {
              nodeManifestRedirectUrl: nodeManifestRedirectUrl
            }),
            overrideShow: true,
            closable: true,
            onClose: closeInfoTooltip
          },
          active: true,
          hoverable: true,
          showSpinner: false,
          onClick: onTooltipToogle
        };
      });
    } : false;
    const contentSyncLoadingAction = usingContentSync ? () => {
      setButtonProps(btnProps => {
        return { ...btnProps,
          tooltip: {
            testId: btnProps.testId,
            content: `Building a new preview`,
            overrideShow: true
          },
          active: true,
          hoverable: true,
          showSpinner: true
        };
      });
    } : false;
    const contentSyncErrorAction = nodeManifestErrorMessage ? buildStatusActions[_enums.BuildStatus.ERROR] : false;
    const contentSyncAction = contentSyncSuccessAction || contentSyncErrorAction || contentSyncLoadingAction;
    const buildStatusAction = // with the introduction of Content Sync eager redirects, button state is no longer tied to build status. So we need a separate action for Content Sync.
    contentSyncAction || buildStatusActions[buildStatus];

    if (typeof buildStatusAction === `function`) {
      buildStatusAction();
    } else {
      setButtonProps({ ...buttonProps,
        active: true,
        hoverable: true
      });
    }
  }, [buildStatus, shouldShowFeedback, nodeManifestRedirectUrl, nodeManifestErrorMessage]);
  const showNotificationInfoIcon = shouldShowFeedback || nodeManifestRedirectUrl || nodeManifestErrorMessage || // we only use build statuses to update UI state when not running content sync logic
  !usingContentSync && [_enums.BuildStatus.SUCCESS, _enums.BuildStatus.ERROR].includes(buildStatus);
  return /*#__PURE__*/_react.default.createElement(_IndicatorButton.default, (0, _extends2.default)({}, buttonProps, {
    onClick: onInfoClick,
    onMouseEnter: buttonProps !== null && buttonProps !== void 0 && buttonProps.active ? trackHover : undefined,
    onTooltipToogle: updateTootipVisibility,
    iconSvg: showNotificationInfoIcon ? _icons.infoAlertIcon : _icons.infoIcon
  }));
};

var _default = InfoIndicatorButton;
exports.default = _default;