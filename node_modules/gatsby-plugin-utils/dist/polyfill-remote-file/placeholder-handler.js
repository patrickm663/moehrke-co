"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.generatePlaceholder = generatePlaceholder;
exports.PlaceholderType = void 0;

var _path = _interopRequireDefault(require("path"));

var _fsExtra = require("fs-extra");

var _fetchRemoteFile = require("gatsby-core-utils/fetch-remote-file");

var _mutex = require("gatsby-core-utils/mutex");

var _fastq = _interopRequireDefault(require("fastq"));

var _gatsbySharp = _interopRequireDefault(require("gatsby-sharp"));

var _cache = require("./utils/cache");

var _mimeTypeHelpers = require("./utils/mime-type-helpers");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let PlaceholderType;
exports.PlaceholderType = PlaceholderType;

(function (PlaceholderType) {
  PlaceholderType["BLURRED"] = "blurred";
  PlaceholderType["DOMINANT_COLOR"] = "dominantColor";
  PlaceholderType["TRACED_SVG"] = "tracedSVG";
})(PlaceholderType || (exports.PlaceholderType = PlaceholderType = {}));

const QUEUE_CONCURRENCY = 10;
const PLACEHOLDER_BASE64_WIDTH = 20;
const PLACEHOLDER_QUALITY = 25;
const PLACEHOLDER_DOMINANT_WIDTH = 200;
const PLACEHOLDER_TRACED_WIDTH = 200;
let tmpDir;
const queue = (0, _fastq.default)(async function ({
  url,
  contentDigest,
  width,
  height,
  type
}, cb) {
  const sharp = await (0, _gatsbySharp.default)();

  if (!tmpDir) {
    const cache = (0, _cache.getCache)();
    tmpDir = await (0, _fsExtra.mkdtemp)(_path.default.join(cache.directory, `placeholder-`));
  }

  const filePath = await (0, _fetchRemoteFile.fetchRemoteFile)({
    url,
    cacheKey: contentDigest,
    directory: tmpDir
  });

  switch (type) {
    case PlaceholderType.BLURRED:
      {
        let buffer;

        try {
          const fileStream = (0, _fsExtra.createReadStream)(filePath);
          const pipeline = sharp();
          fileStream.pipe(pipeline);
          buffer = await pipeline.resize(PLACEHOLDER_BASE64_WIDTH, Math.ceil(PLACEHOLDER_BASE64_WIDTH / (width / height))).toBuffer();
        } catch (e) {
          buffer = await (0, _fsExtra.readFile)(filePath);
        }

        return cb(null, `data:image/jpg;base64,${buffer.toString(`base64`)}`);
      }

    case PlaceholderType.DOMINANT_COLOR:
      {
        const fileStream = (0, _fsExtra.createReadStream)(filePath);
        const pipeline = sharp({
          failOnError: false
        });
        fileStream.pipe(pipeline);
        const {
          dominant
        } = await pipeline.stats();
        return cb(null, dominant ? `rgb(${dominant.r},${dominant.g},${dominant.b})` : `rgba(0,0,0,0)`);
      }

    case PlaceholderType.TRACED_SVG:
      {
        let buffer;

        try {
          const fileStream = (0, _fsExtra.createReadStream)(filePath);
          const pipeline = sharp();
          fileStream.pipe(pipeline);
          buffer = await pipeline.resize(PLACEHOLDER_BASE64_WIDTH, Math.ceil(PLACEHOLDER_BASE64_WIDTH / (width / height))).toBuffer();
        } catch (err) {
          buffer = await (0, _fsExtra.readFile)(filePath);
        }

        const [{
          trace,
          Potrace
        }, {
          optimize
        }, {
          default: svgToMiniDataURI
        }] = await Promise.all([Promise.resolve().then(() => _interopRequireWildcard(require(`@gatsbyjs/potrace`))), Promise.resolve().then(() => _interopRequireWildcard(require(`svgo`))), Promise.resolve().then(() => _interopRequireWildcard(require(`mini-svg-data-uri`)))]);
        trace(buffer, {
          color: `lightgray`,
          optTolerance: 0.4,
          turdSize: 100,
          turnPolicy: Potrace.TURNPOLICY_MAJORITY
        }, async (err, svg) => {
          if (err) {
            return cb(err);
          }

          try {
            const {
              data
            } = await optimize(svg, {
              multipass: true,
              floatPrecision: 0,
              plugins: [{
                name: `preset-default`,
                params: {
                  overrides: {
                    // customize default plugin options
                    removeViewBox: false,
                    // or disable plugins
                    addAttributesToSVGElement: {
                      attributes: [{
                        preserveAspectRatio: `none`
                      }]
                    }
                  }
                }
              }]
            });
            return cb(null, svgToMiniDataURI(data).replace(/ /gi, `%20`));
          } catch (err) {
            return cb(err);
          }
        });
      }
  }
}, QUEUE_CONCURRENCY); // eslint-disable-next-line consistent-return

async function generatePlaceholder(source, placeholderType) {
  switch (placeholderType) {
    case PlaceholderType.BLURRED:
      {
        return {
          fallback: await runPlaceholder({
            id: source.id,
            placeholderUrl: source.placeholderUrl,
            originalUrl: source.url,
            format: (0, _mimeTypeHelpers.getImageFormatFromMimeType)(source.mimeType),
            width: source.width,
            height: source.height,
            contentDigest: source.internal.contentDigest,
            type: PlaceholderType.BLURRED,
            placeholderOptions: {
              width: PLACEHOLDER_BASE64_WIDTH,
              quality: PLACEHOLDER_QUALITY
            }
          })
        };
      }

    case PlaceholderType.DOMINANT_COLOR:
      {
        return {
          backgroundColor: await runPlaceholder({
            id: source.id,
            placeholderUrl: source.placeholderUrl,
            originalUrl: source.url,
            format: (0, _mimeTypeHelpers.getImageFormatFromMimeType)(source.mimeType),
            width: source.width,
            height: source.height,
            contentDigest: source.internal.contentDigest,
            type: PlaceholderType.DOMINANT_COLOR,
            placeholderOptions: {
              width: PLACEHOLDER_DOMINANT_WIDTH,
              quality: PLACEHOLDER_QUALITY
            }
          })
        };
      }

    case PlaceholderType.TRACED_SVG:
      {
        return {
          fallback: await runPlaceholder({
            id: source.id,
            placeholderUrl: source.placeholderUrl,
            originalUrl: source.url,
            format: (0, _mimeTypeHelpers.getImageFormatFromMimeType)(source.mimeType),
            width: source.width,
            height: source.height,
            contentDigest: source.internal.contentDigest,
            type: PlaceholderType.TRACED_SVG,
            placeholderOptions: {
              width: PLACEHOLDER_TRACED_WIDTH,
              quality: PLACEHOLDER_QUALITY
            }
          })
        };
      }
  }
}

async function runPlaceholder({
  placeholderUrl,
  originalUrl,
  width,
  height,
  id,
  contentDigest,
  type,
  placeholderOptions
}) {
  const cache = (0, _cache.getCache)();
  const cacheKey = `image-cdn:${id}-${contentDigest}:${type}`;
  let cachedValue = await cache.get(cacheKey);

  if (cachedValue) {
    return cachedValue;
  }

  const mutex = (0, _mutex.createMutex)(`gatsby-plugin-utils:placeholder:${id}-${contentDigest}`);
  await mutex.acquire();

  try {
    // check cache again after mutex is acquired
    cachedValue = await cache.get(cacheKey);

    if (cachedValue) {
      return cachedValue;
    }

    let url = originalUrl;

    if (placeholderUrl) {
      url = generatePlaceholderUrl({
        url: placeholderUrl,
        originalWidth: width,
        originalHeight: height,
        ...placeholderOptions
      });
    }

    const result = await new Promise((resolve, reject) => {
      queue.push({
        url,
        contentDigest,
        width,
        height,
        type
      }, (err, result) => {
        if (err) {
          reject(err);
          return;
        }

        resolve(result);
      });
    });
    await cache.set(cacheKey, result);
    return result;
  } finally {
    await mutex.release();
  }
}

function generatePlaceholderUrl({
  url,
  width,
  quality,
  originalWidth,
  originalHeight
}) {
  const aspectRatio = originalWidth / originalHeight;
  return url.replace(`%width%`, String(width)).replace(`%height%`, Math.floor(width / aspectRatio).toString()).replace(`%quality%`, String(quality));
}