{"version":3,"sources":["../../../src/utils/jobs/worker-messaging.ts"],"names":["hasActiveWorkerJobs","activeWorkerJobs","initJobsMessagingInMainProcess","workerPool","onMessage","msg","workerId","type","MESSAGE_TYPES","JOB_CREATED","store","dispatch","internalActions","createJobV2FromInternalJob","payload","then","result","sendMessage","JOB_COMPLETED","id","catch","error","JOB_FAILED","message","finally","resolve","waitUntilWorkerJobsAreComplete","promise","Promise","deferredWorkerPromises","Map","gatsbyWorkerMessenger","initJobsMessagingInWorker","isWorker","deferredPromise","get","Error","delete","reject","WorkerError","maybeSendJobToMainProcess","job","deferredWorkerPromise","set","undefined"],"mappings":"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","sourcesContent":["import pDefer from \"p-defer\"\n\nimport {\n  MESSAGE_TYPES,\n  InternalJob,\n  IJobCreatedMessage,\n  WorkerError,\n} from \"./types\"\nimport { store } from \"../../redux\"\nimport { internalActions } from \"../../redux/actions\"\nimport { GatsbyWorkerPool } from \"../worker/types\"\nimport { isWorker, getMessenger } from \"../worker/messaging\"\n\nlet hasActiveWorkerJobs: pDefer.DeferredPromise<void> | null = null\nlet activeWorkerJobs = 0\n\nexport function initJobsMessagingInMainProcess(\n  workerPool: GatsbyWorkerPool\n): void {\n  workerPool.onMessage((msg, workerId) => {\n    if (msg.type === MESSAGE_TYPES.JOB_CREATED) {\n      if (activeWorkerJobs === 0) {\n        hasActiveWorkerJobs = pDefer<void>()\n      }\n      activeWorkerJobs++\n      store\n        .dispatch(internalActions.createJobV2FromInternalJob(msg.payload))\n        .then(result => {\n          workerPool.sendMessage(\n            {\n              type: MESSAGE_TYPES.JOB_COMPLETED,\n              payload: {\n                id: msg.payload.id,\n                result,\n              },\n            },\n            workerId\n          )\n        })\n        .catch(error => {\n          workerPool.sendMessage(\n            {\n              type: MESSAGE_TYPES.JOB_FAILED,\n              payload: {\n                id: msg.payload.id,\n                error: error.message,\n              },\n            },\n            workerId\n          )\n        })\n        .finally(() => {\n          if (--activeWorkerJobs === 0) {\n            hasActiveWorkerJobs?.resolve()\n            hasActiveWorkerJobs = null\n          }\n        })\n    }\n  })\n}\n\nexport const waitUntilWorkerJobsAreComplete = (): Promise<void> =>\n  hasActiveWorkerJobs ? hasActiveWorkerJobs.promise : Promise.resolve()\n\n/**\n * This map is ONLY used in worker. It's purpose is to keep track of promises returned to plugins\n * when creating jobs (in worker context), so that we can resolve or reject those once main process\n * send back their status.\n */\nconst deferredWorkerPromises = new Map<\n  InternalJob[\"id\"],\n  pDefer.DeferredPromise<Record<string, unknown>>\n>()\nconst gatsbyWorkerMessenger = getMessenger()\nexport function initJobsMessagingInWorker(): void {\n  if (isWorker && gatsbyWorkerMessenger) {\n    gatsbyWorkerMessenger.onMessage(msg => {\n      if (msg.type === MESSAGE_TYPES.JOB_COMPLETED) {\n        const { id, result } = msg.payload\n        const deferredPromise = deferredWorkerPromises.get(id)\n\n        if (!deferredPromise) {\n          throw new Error(\n            `Received message about completed job that wasn't scheduled by this worker`\n          )\n        }\n\n        deferredPromise.resolve(result)\n        deferredWorkerPromises.delete(id)\n      } else if (msg.type === MESSAGE_TYPES.JOB_FAILED) {\n        const { id, error } = msg.payload\n        const deferredPromise = deferredWorkerPromises.get(id)\n\n        if (!deferredPromise) {\n          throw new Error(\n            `Received message about failed job that wasn't scheduled by this worker`\n          )\n        }\n\n        deferredPromise.reject(new WorkerError(error))\n        deferredWorkerPromises.delete(id)\n      }\n    })\n  }\n}\n\n/**\n * Forwards job to main process (if executed in worker context) and returns\n * a promise. Will return `undefined` if called not in worker context.\n */\nexport function maybeSendJobToMainProcess(\n  job: InternalJob\n): Promise<Record<string, unknown>> | undefined {\n  if (isWorker && gatsbyWorkerMessenger) {\n    const deferredWorkerPromise = pDefer<Record<string, unknown>>()\n\n    const msg: IJobCreatedMessage = {\n      type: MESSAGE_TYPES.JOB_CREATED,\n      payload: job,\n    }\n\n    gatsbyWorkerMessenger.sendMessage(msg)\n\n    // holds on to promise\n    deferredWorkerPromises.set(job.id, deferredWorkerPromise)\n\n    return deferredWorkerPromise.promise\n  }\n\n  return undefined\n}\n"],"file":"worker-messaging.js"}